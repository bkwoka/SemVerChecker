To jest krytyczny punkt, który często umyka w prostych implementacjach SemVer, a w świecie IoT może prowadzić do poważnych problemów (np. "cegłowania" urządzeń produkcyjnych niestabilnym softem).

Oto szczegółowa analiza problemu, dlaczego obecna implementacja jest ryzykowna, oraz gotowe rozwiązanie zgodne z filozofią "Safety First".

1. Analiza Problemu: "Pułapka Pre-release"

W specyfikacji SemVer (i implementacji node-semver):

Kolejność (Precedence): 1.0.0 < 1.0.1-alpha < 1.0.1.

Zakresy (Ranges): Zakres ^1.0.0 (czyli "wszystko kompatybilne z 1.0.0") automatycznie wyklucza wersje pre-release, chyba że użytkownik jawnie o nie poprosi.

Twój obecny kod:
Sprawdza tylko matematyczną wyższość (>) i zgodność Major/Minor.

code
C++
download
content_copy
expand_less
// Sytuacja:
// Wymaganie (Requirement): "1.0.0" (Stabilna wersja)
// Kandydat (Available):    "1.1.0-beta.1" (Niestabilna wersja z nowym featurem)

// Twój kod robi:
if (candidate < requirement) ... // Fałsz (1.1.0-beta.1 > 1.0.0)
if (candidate.major != requirement.major) ... // Fałsz (1 == 1)

// Wynik: TRUE.
// Skutek: Urządzenie pobiera betę.

Ryzyko w IoT:
Jeśli wypuścisz wersję 1.1.0-beta do testów dla działu QA, Twoje 10,000 urządzeń u klientów (szukających aktualizacji dla 1.0.0) zobaczy ją, uzna za "nowszą i pasującą", i zainstaluje. To jest katastrofa wdrożeniowa.

2. Rozwiązanie Programistyczne (Korekta satisfies)

Należy zmienić logikę satisfies, aby domyślnie odrzucała wersje pre-release, jeśli wymagana wersja (baza) sama nie jest pre-release.

Zmiana w pliku nagłówkowym (SemVerChecker.h)

Zmieniamy sygnaturę metody, dodając opcjonalną flagę (koszt pamięciowy: żaden, to idzie przez rejestr procesora).

code
C++
download
content_copy
expand_less
/**
 * @param includePrerelease Jeśli true, pozwala na instalację wersji unstable (alpha/beta)
 *                          nawet jeśli requirement jest stabilny.
 */
bool satisfies(const SemVer& requirement, bool includePrerelease = false) const;
Zmiana w pliku źródłowym (SemVerChecker.cpp)

Implementujemy logikę wykluczania:

code
C++
download
content_copy
expand_less
bool SemVer::satisfies(const SemVer& requirement, bool includePrerelease) const {
    // 1. Walidacja podstawowa
    if (!_valid || !requirement._valid) return false;

    // 2. Wersja musi być >= od wymaganej
    if (*this < requirement) return false;

    // 3. Sprawdzenie Major (Breaking changes)
    if (major != requirement.major) return false;

    // 4. Specjalna obsługa 0.x.x (Minor to breaking change)
    if (major == 0 && minor != requirement.minor) return false;

    // --- NOWA LOGIKA: Ochrona przed Pre-release ---
    
    // Sprawdź czy kandydat (this) jest wersją pre-release
    bool iAmPrerelease = (getPrerelease()[0] != '\0');

    // Jeśli jestem pre-release...
    if (iAmPrerelease) {
        // ...a flaga globalna na to nie pozwala...
        if (!includePrerelease) {
            // ...to musimy sprawdzić, czy requirement też był pre-release.
            // Zasada: Jeśli requirement to "1.0.0-alpha", to "1.0.0-beta" jest OK.
            // Ale jeśli requirement to "1.0.0", to "1.0.1-alpha" jest ZABRONIONE.
            
            bool reqIsPrerelease = (requirement.getPrerelease()[0] != '\0');
            
            if (!reqIsPrerelease) {
                return false; // ODRZUĆ: Stabilny requirement nie chce unstable kandydata
            }
            
            // Opcjonalnie (Node-semver strict):
            // Pre-release spełnia requirement TYLKO jeśli mają ten sam zestaw [Major, Minor, Patch].
            // Np. ^1.2.3-alpha pozwala na 1.2.3-beta, ale NIE pozwala na 1.2.4-beta.
            // W świecie Embedded, dla uproszczenia, można ten krok pominąć lub dodać:
            if (major != requirement.major || 
                minor != requirement.minor || 
                patch != requirement.patch) {
                 return false; 
            }
        }
    }

    return true;
}
3. Mechanizm Zarządzania Flotą (Device Management)

Teraz, mając taką logikę, możesz łatwo zarządzać, które urządzenia mogą przyjąć wersje niestabilne. Nie musisz hardcodować tego w bibliotece – to decyzja na poziomie aplikacji (.ino).

Scenariusz:

Urządzenia "Produkcyjne" (u klientów).

Urządzenia "Beta Testers" (u wybranych użytkowników).

Urządzenia "Dev/QA" (w biurze).

Implementacja w FirmwareUpdate.ino:

code
C++
download
content_copy
expand_less
// Konfiguracja urządzenia (może być zapisana w EEPROM/NVS)
enum Channel {
  STABLE, // Produkcja
  BETA,   // Early adopters
  DEV     // Internal
};

// Zapisane w konfiguracji urządzenia
Channel myChannel = STABLE; 

void checkUpdate() {
    SemVer current("1.0.0");
    SemVer available("1.1.0-rc.1"); // Kandydat z serwera

    // Decyzja: Czy pozwalamy na pre-release?
    bool allowUnstable = (myChannel == BETA || myChannel == DEV);

    // Sprawdzenie
    if (available.satisfies(current, allowUnstable)) {
        Serial.println("Aktualizuję!");
    } else {
        Serial.println("Ignoruję wersję (zbyt niestabilna lub niekompatybilna).");
    }
}
Wynik działania dla powyższego kodu:

Dla kanału STABLE (allowUnstable = false):

available (1.1.0-rc.1) ma flagę pre-release.

current (1.0.0) nie ma flagi pre-release.

satisfies zwraca FALSE.

Urządzenie bezpieczne.

Dla kanału BETA (allowUnstable = true):

Flaga includePrerelease pozwala pominąć restrykcyjne sprawdzanie.

Weryfikowane są tylko Major/Minor.

satisfies zwraca TRUE.

Urządzenie testowe otrzymuje aktualizację.

Podsumowanie zmian do wdrożenia

Zaktualizuj SemVerChecker.h dodając bool includePrerelease = false do satisfies.

Zaktualizuj SemVerChecker.cpp o blokadę logiczną (jak w punkcie 2).

Zaktualizuj przykłady (examples/), aby pokazać, jak używać tego parametru w kontekście OTA.

To podejście jest zgodne z "Fail Fast" i "Security by Design" – domyślne zachowanie (bez podania drugiego argumentu) jest bezpieczne (konserwatywne), a odblokowanie ryzyka (wersji alpha) wymaga jawnej decyzji programisty.